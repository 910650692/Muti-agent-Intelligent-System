# SGM 车载AI助手 - 架构全景

## 一、整体架构：端云协同

```
┌─────────────────────────────────────────────────────────────────┐
│                          云端服务                                 │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                    业务Agent层                             │   │
│  │  ┌────────────┐  ┌────────────┐  ┌────────────┐          │   │
│  │  │Supervisor  │→│ 车控Agent   │  │ 导航Agent  │ ...      │   │
│  │  │  (协调者)  │  │            │  │            │          │   │
│  │  └────────────┘  └────────────┘  └────────────┘          │   │
│  └──────────────────────────────────────────────────────────┘   │
│                           ↕ MCP Client                           │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                    记忆服务                                │   │
│  │  生产 → 存储(向量DB+关系DB) → 召回                        │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                   │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                  主动服务链路                              │   │
│  │  事件触发 → 防打扰判断 → 生成建议 → 用户确认              │   │
│  └──────────────────────────────────────────────────────────┘   │
└───────────────────────────┬─────────────────────────────────────┘
                            │ 网络通信
┌───────────────────────────┴─────────────────────────────────────┐
│                          端侧服务                                 │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │              语音助手 (语音交互入口)                       │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                   │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │            MCP Server (Android Service形式)               │   │
│  │  封装车上能力：车控、导航、多媒体、天气...                │   │
│  │  通过MCP协议暴露给云端Agent调用                            │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                   │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │              感知服务 (事件采集)                           │   │
│  │  位置变化、时间触发、车辆状态、日历事件...                │   │
│  └──────────────────────────────────────────────────────────┘   │
└───────────────────────────────────────────────────────────────┘
```

**关键点：**
- **端侧MCP Server**: Android Service形式，封装车上各种能力，通过MCP协议提供给云端
- **云端MCP Client**: Agent通过MCP协议function call调用端侧工具
- **两条互斥链路**: 用户请求链路 vs 主动服务链路，不会并发运行

---

## 二、链路1：用户请求处理 (Supervisor模式)

### 2.1 技术架构

```python
# LangGraph StateGraph - 多Node共享State
from langgraph.graph import StateGraph

class AgentState(TypedDict):
    messages: List[BaseMessage]      # 对话历史
    next_agent: str                  # 下一个执行的Agent
    user_id: str                     # 用户ID
    memory_context: str              # 召回的记忆上下文
    task_status: dict                # 任务执行状态
    conversation_id: str             # 会话ID
    # ... 其他共享状态
```

### 2.2 Supervisor工作流程

```
用户输入 → Supervisor → 业务Agent → Supervisor → 返回结果
   ↓
记忆召回 (并行注入到Supervisor)
```

**Supervisor职责：**
1. **意图分类**: 判断用户请求属于哪个领域（车控/导航/天气/闲聊...）
2. **协调调度**:
   - 单Agent场景：直接路由到对应Agent
   - 多Agent协作：处理前置依赖（如开空调需先关车窗）
3. **结果判断**: 检查Agent执行结果，决定是否需要继续调用其他Agent

### 2.3 多Agent协作示例

```
用户: "帮我开空调"
                              ↓
                    Supervisor (分析)
              发现需要先关车窗（前置依赖）
                              ↓
                    ┌─────────┴─────────┐
                    ↓                   ↓
            车窗Agent (关窗)     等待完成
                    ↓
            Supervisor (检查)
                    ↓
            空调Agent (开空调)
                    ↓
            Supervisor (汇总)
                    ↓
            返回: "已为您关窗并开启空调"
```

### 2.4 State同步机制

**框架自动管理，无需手动同步：**
- 所有Node（Supervisor、各业务Agent）共享同一个`AgentState`
- LangGraph在Node切换时自动传递State
- Node通过`return`更新State，框架负责合并

```python
# Supervisor Node
def supervisor_node(state: AgentState) -> AgentState:
    # 1. 读取共享State
    messages = state["messages"]
    memory = state["memory_context"]

    # 2. 决策下一个Agent
    next_agent = classify_intent(messages[-1])

    # 3. 更新State并返回
    return {"next_agent": next_agent}

# 车控Agent Node
def vehicle_control_node(state: AgentState) -> AgentState:
    # 自动拿到Supervisor更新后的State
    task = state["next_agent"]

    # 调用MCP工具执行
    result = call_mcp_tool("vehicle_control", ...)

    # 更新State
    return {
        "messages": [AIMessage(content=result)],
        "task_status": {"vehicle_control": "completed"}
    }
```

---

## 三、链路2：主动服务 (独立链路)

### 3.1 触发机制

```
端侧感知服务 → 云端主动服务Agent → 防打扰判断 → 生成建议 → 推送端侧 → 用户确认
```

**事件源：**
- **位置变化**: 快到家了提醒开启家居模式
- **时间触发**: 早上7点提醒日程
- **车辆状态**: 电量低提醒充电
- **日历事件**: 会议前15分钟提醒出发
- **天气变化**: 要下雨了提醒关天窗

### 3.2 防打扰机制

```python
# 主动服务判断逻辑
if 用户正在对话:
    return  # 不打扰

if 驾驶场景 and 复杂路况:
    return  # 安全优先

if 用户设置了免打扰:
    return

if 近期已推送相似内容:
    return  # 避免骚扰

# 通过后才推送
send_proactive_suggestion()
```

### 3.3 与用户请求的互斥

- **互斥原则**: 两条链路不会同时进行
- **优先级**: 用户主动请求 > 主动服务
- **状态标记**: 通过全局flag控制当前活跃链路

---

## 四、记忆系统

### 4.1 记忆生产

| 类型 | 触发时机 | 示例 |
|------|---------|------|
| **初见引导** | 用户首次使用 | "您好，我是您的智能助手..." |
| **被动记忆** | 用户对话中提到 | "我明天要去机场" → 记录行程 |
| **主动记忆** | Agent主动询问 | "请问您常用的充电站是?" → 记录偏好 |
| **记忆快照** | 对话结束时 | 总结本次对话关键信息 |

### 4.2 记忆存储

**双存储架构：**

```
向量数据库 (Chroma/Faiss)           关系型数据库 (PostgreSQL)
├─ 对话历史向量                      ├─ 结构化偏好
├─ 用户画像向量                      │  └─ 常用地点、充电站、温度偏好...
└─ 快照摘要向量                      ├─ 行程计划
                                     └─ 用户关系（家人、朋友）
```

### 4.3 记忆召回

**多路召回 + 融合排序：**

1. **标签召回**: 根据意图标签直接匹配（如"导航" → 历史导航记录）
2. **语义召回**: 向量相似度检索（用户说"回家" → 召回家地址）
3. **快照召回**: 上下文摘要（最近几次对话的关键信息）
4. **画像召回**: 用户偏好（空调温度、音乐类型...）

**召回时机：**
- **Supervisor处理前**: 并行召回相关记忆，注入到Prompt
- **Agent执行时**: 根据需要二次召回具体数据

### 4.4 面试可"埋"的坑 + 解决方案

| 坑点 | 场景 | 解决方案 |
|------|------|----------|
| **召回噪音** | 语义召回返回不相关的历史对话 | 混合召回策略 + 重排序模型 + 时间衰减 |
| **记忆冲突** | "我家地址是A" vs "我住在B" | 时间戳优先 + 用户确认机制 |
| **冷启动打断** | 新用户无记忆，Agent频繁追问 | 首次使用引导流程 + 批量采集 + 自然融入 |
| **向量检索性能** | 用户量大，召回延迟高 | 索引优化(HNSW) + 分片 + 缓存热数据 |

---

## 五、MCP工具层

### 5.1 端侧MCP Server能力封装

```
MCP Server (Android Service)
├─ vehicle_control: 车控（车窗、空调、座椅...）
├─ navigation: 导航（路径规划、POI搜索...）
├─ multimedia: 多媒体（音乐、电台、视频...）
├─ weather: 天气查询
├─ calendar: 日历管理
└─ smart_home: 智能家居联动
```

### 5.2 云端Agent调用示例

```python
# Agent通过MCP协议调用端侧工具
from mcp import MCPClient

async def vehicle_control_agent(state: AgentState):
    messages = state["messages"]
    user_input = messages[-1].content

    # LLM决策需要调用什么工具
    llm_response = llm.invoke(
        messages,
        tools=[vehicle_control_tool]  # MCP工具注册
    )

    # 如果LLM决定调用工具
    if llm_response.tool_calls:
        tool_call = llm_response.tool_calls[0]

        # 通过MCP Client调用端侧
        result = await mcp_client.call_tool(
            name=tool_call["name"],       # "vehicle_control"
            arguments=tool_call["args"]   # {"action": "open_window"}
        )

        return {"messages": [AIMessage(content=result)]}
```

---

## 六、关键技术点总结

### 6.1 为什么不需要Router节点？

- **合并到Supervisor**: Supervisor既做意图分类又做协调
- **避免冗余**: Router只做分类没有协调能力，单独设置多一层传递
- **LangGraph特性**: Conditional Edge可以根据State动态路由

### 6.2 什么时候需要Supervisor？

**需要场景：**
- 多Agent协作（前置依赖、任务分解）
- 复杂决策流程（多轮交互、状态检查）
- 动态路由（根据上下文决定下一步）

**不需要场景：**
- 单一Agent处理（如纯闲聊）
- 简单映射（固定规则路由）

### 6.3 不是分布式多Agent

- **同一个StateGraph内**: 所有Node共享内存State
- **本地函数调用**: Node之间是Python函数调用，不是RPC
- **无需A2A协议**: 不涉及跨进程Agent通信

---

## 七、面试Q&A速查

### Q1: 为什么选择端云协同架构？

**A:**
- **端侧优势**: 低延迟（语音交互）、离线能力、隐私保护
- **云端优势**: 算力充足（大模型推理）、记忆存储、功能迭代快
- **协同方式**: 端侧MCP Server封装车上能力，云端Agent通过MCP协议调用

### Q2: 记忆系统的召回策略是什么？

**A:**
- **多路召回**: 标签召回 + 语义召回 + 快照召回 + 画像召回
- **召回时机**: Supervisor处理前并行注入，Agent执行时二次召回
- **解决噪音**: 重排序模型 + 时间衰减 + 相关度阈值

### Q3: Supervisor和Router的区别？

**A:**
- **Router**: 仅做意图分类，静态路由
- **Supervisor**: 意图分类 + 协调调度 + 结果判断，支持多Agent协作
- **我们的选择**: 合并到Supervisor，避免冗余节点

### Q4: 主动服务怎么避免打扰用户？

**A:**
- **场景判断**: 驾驶场景、复杂路况不打扰
- **对话互斥**: 用户主动请求时不推送
- **防骚扰**: 相似内容去重、用户免打扰设置
- **确认机制**: 推送建议需用户确认才执行

### Q5: 遇到过什么坑？怎么解决的？

**A:**
（选一个详细讲，参考4.4表格）

例如**记忆冲突**：
- **场景**: 用户说"我家在A"，后来又说"我住B"
- **现象**: 召回时返回多个冲突地址，Agent困惑
- **解决**:
  1. 时间戳优先（最新的记忆）
  2. 用户确认机制（检测到冲突时主动询问）
  3. 记忆覆盖策略（同类型记忆自动更新）

### Q6: 多Agent怎么协作的？举个例子

**A:**
开空调需要先关车窗：
1. Supervisor识别意图"开空调"
2. 检查前置条件：车窗是否关闭
3. 如果车窗开着 → 先调用车窗Agent关窗
4. 车窗Agent执行完毕 → Supervisor检查状态
5. 状态OK → 调用空调Agent开空调
6. 汇总结果返回用户："已为您关窗并开启空调"

**技术实现**: LangGraph StateGraph，通过Conditional Edge控制流程

---

## 八、技术栈

- **框架**: LangGraph (StateGraph)
- **LLM**: Claude / GPT-4 / 国产大模型
- **向量数据库**: Chroma / Faiss
- **关系数据库**: PostgreSQL
- **端侧**: Android (MCP Server)
- **协议**: MCP (Model Context Protocol)
- **部署**: 云端服务 (FastAPI + Docker)

---

## 九、未来优化方向

1. **记忆质量提升**:
   - 引入记忆重要性评分
   - 记忆自动归档（冷热分离）
   - 记忆纠错机制

2. **主动服务智能化**:
   - 用户行为预测模型
   - 个性化推送策略
   - 多模态提醒（语音+视觉）

3. **Agent能力扩展**:
   - 长期规划能力（多日行程安排）
   - 跨领域任务（导航+娱乐组合）
   - 情感识别与回应

4. **性能优化**:
   - Agent并行执行（非依赖任务）
   - 召回结果缓存
   - 端侧模型部署（降低云端依赖）

---

**文档版本**: v1.0
**最后更新**: 2026-01-04
**维护者**: [Your Name]
